#!/usr/bin/env python
import eventlet
eventlet.monkey_patch()  # noqa

import colors
import os
import sys
import re
from tabulate import tabulate
from subprocess32 import call, check_output, check_call
from os.path import join, basename, expanduser


def main():
    width = int(check_output(['stty', 'size']).split()[1])
    repos = readfile(expanduser('~/.my_repos')).strip('\n').split('\n')
    repos = [expanduser(x) for x in repos]

    # Update repos.
    if '-f' in sys.argv:
        print 'updating repos...'
        tasks = [eventlet.spawn(update_repo, x) for x in repos]
        for task in tasks:
            task.wait()

    # Print status of repos.
    print
    for repo in repos:
        os.chdir(repo)
        home = home_branch(repo)

        status = check_output(['git', '-c', 'color.status=always', 'status',
                               '--short']).rstrip()

        msg = colors.blue(basename(repo))
        current = current_branch(repo)
        if home not in current:
            msg += ' ' + colors.yellow(current)
        print msg

        if status:
            print status
            print

        branch_status(repo, home)
        print


def update_repo(repo):
    home = home_branch(repo)
    head = readfile(join(repo, '.git/HEAD')).strip()
    home_commit = check_output(['git', 'rev-parse', home], cwd=repo).strip()
    if (
        head == 'ref: refs/heads/master' and
        check_output(['git', 'status', '--short'], cwd=repo).strip() == ''
    ):
        action = lambda: call(['git', 'merge', home], cwd=repo)
    elif head == home_commit:
        action = lambda: check_call([
            'bash', '-c',
            'git checkout "{}" &> /dev/null'.format(home)
        ], cwd=repo)
    else:
        action = lambda: None
    call(['git', 'fetch', '--all', '--prune'], cwd=repo)
    action()
    return home


def current_branch(repo):
    head = readfile(join(repo, '.git/HEAD')).strip()
    prefix = 'ref: refs/heads/'
    if head.startswith(prefix):
        return head[len(prefix):]
    else:
        branches = (matching_branches(join(repo, '.git/refs/remotes/'), head) +
                    matching_branches(join(repo, '.git/refs/tags'), head))
        if branches:
            return '({})'.format(' '.join(branches))
        else:
            return head


def matching_branches(dir, commit_id):
    if not dir.endswith('/'):
        dir += '/'
    return [x[len(dir):] for x in get_files(dir)
            if readfile(x).strip() == commit_id]


def branch_status(repo, home_b):
    branches = local_branches(repo)
    if branches:
        b_width = max(len(x) for x in branches)
    for branch in branches:
        output = check_output(['git', 'rev-list', '--count', '--left-right',
                               '{}...{}'.format(branch, home_b)],
                              cwd=repo)
        ahead, behind = [int(x) for x in output.strip().split()]

        if ahead == 0 and behind == 0:
            msg = ''
        elif ahead == 0:
            msg = colors.yellow('merged')
        else:
            msg = '{} ahead, {} behind'.format(ahead, behind)

        print '  {} {}'.format(colors.green(branch.ljust(b_width)), msg)


def home_branch(repo):
    output = check_output(['git', 'branch', '-a'], cwd=repo)
    if 'upstream/develop' in output:
        return 'upstream/develop'
    elif 'upstream/master' in output:
        return 'upstream/master'
    else:
        return 'origin/master'


def local_branches(repo):
    heads_dir = join(repo, '.git/refs/heads')
    return [x[len(heads_dir)+1:] for x in get_files(heads_dir)]


def get_files(dir):
    out = []
    for root, dirs, files in os.walk(dir):
        for name in files:
            out.append(join(root, name))
    return out


def readfile(path):
    with open(path) as f:
        return f.read()


if __name__ == '__main__':
    # import ipdb
    # with ipdb.launch_ipdb_on_exception():
    main()
